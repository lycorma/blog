#### 各种类型

- 静态类型：使用之前需要确定变量类型的语言叫做静态类型语言
- 动态类型：运行时需要检查变量类型的语言叫做动态类型语言
- 强类型：不允许隐式转换的语言
- 弱类型：允许隐式转换的语言
- 编译型语言：在程序执行之前，需要编译器进行编译并生成二进制文件的语言
- 解释型语言：每次运行时通过解释器进行动态解释和执行的语言

```
js是动态弱类型的解释型语言。
```



#### 数据存储

js的内存模型，js在执行中的内存空间主要有三种

- 代码空间
- 栈空间： 存储执行上下文
- 堆空间： 存储对象/函数，大数据等



#### 执行上下文

- 类型有：全局执行上下文和函数执行上下文（还有个eval，一般不说）
- 是js执行一段代码时的运行环境，里面有执行时用到的变量、函数等
- 一段代码经过编译后，生成执行上下文和可执行代码两个部分
- 执行上下文包含变量环境和词法环境两个部分
  - 变量环境用来实现函数作用域
  - 词法环境用来实现块级作用域
- 同名变量或函数的处理
  - 后声明的覆盖先声明的
  - 函数声明覆盖变量声明。需要注意的是：只有声明时函数会覆盖变量，赋值就是正常逻辑了。



#### 编译过程

```
基本概念：编译器compiler、解释器Interpreter、字节码、抽象语法树AST、即时编译JIT
```

- 全局编译一次，后续每执行到一个函数会编译一次
- 先遍历一遍源代码，经过词法分析和语法分析生成抽象语法树AST（是一种数据结构）
- 有了AST后，生成执行上下文
  - 变量提升
    - var声明的变量和外部引用outer存到变量环境
    - let和const声明的变量存进词法环境（块级作用域内的let/const声明不做处理）
    - 如果变量是基础类型如Boolean、Number等，直接将值存在栈空间内
    - 如果是对象或函数，则存在堆空间内，只返回一个堆内地址给变量做值
  - 如果函数内还有函数，会对内部函数做一次快速扫描，
    - 如果inner函数引用了outer函数的变量（闭包），则在堆空间中创建一个‘closure(outer)’对象（内部对象，js无法访问），将用到的变量依次添加上去
    - 并在函数执行上下文的变量环境中创建同名变量closure(outer)，值为堆空间中的地址
- 解释器 Ignition 根据AST生成字节码（不是机器码，是从手机的内存占用考虑，机器码会占用大量内存，字节码就问题不大），再逐行解释字节码，生成机器码，执行。
- 如果发现有多次重复执行的热点代码，编译器turbofan就会将其编译为机器码，省去解释执行的时间

``` 
即时编译JIT： just-in-time compilation，是一种在程序执行过程中（在运行期）而不是在执行之前进行编译的方法
```

```
note: 
- 之所以要引入let 和const，是因为变量提升带来了一系列问题如变量被覆盖、未被垃圾回收等
- 块级作用域是在词法环境内维护了一个小型栈结构，编译时将let const声明的变量压入栈底；执行时将块级作用域压入栈顶，执行完后弹出
```



#### 执行过程

- (编译过程已经处理了：变量提升并生成全局执行上下文，生成可执行代码)

- 开始执行可执行代码

- 遇到变量时查找路径为： 

  词法环境的块级作用域栈  -> 变量环境 -> 变量环境的outer一路查找作用域链 -> 全局作用域 -> 报错

- 遇到函数调用：创建函数执行上下文，并压入执行上下文栈

- 函数执行完后，将此函数上下文弹出栈

- 重复出栈入栈...

- 弹出全局执行上下文



#### 作用域

- 指在程序中**定义变量**的区域，决定了变量的生命周期（简单理解：变量和函数的**可访问范围**）
- 由词法作用域决定。
  - 词法作用域是由代码中函数声明的位置决定的，编译阶段就确定了
  - 所以词法作用域是静态作用域，通过它就能知道代码在执行过程中怎么查找标识符
- 分为全局作用域、函数作用域、块级作用域（es6）（变量和函数在哪块作用域声明的，就只能在哪块域用）
- 每个执行上下文的变量环境中都存放了一个指向外部执行上下文的外部引用：outer

#### 作用域链

当前执行上下文的outer -- outer指向的执行上下文的outer -- ... - 全局作用域 这个查找链条

理解作用域链是理解闭包的基础



#### 闭包

- 根据词法作用域的规则，内部函数总能访问其外部函数声明的变量。

- 当外部函数返回一个内部函数时，即使外部函数调用已经结束了，从执行上下文栈弹出去了，内部函数引用的外部变量依然保存在内存中，这些变量集合就叫**闭包**
- 如果外部函数叫A，变量集合就称为A的闭包
- 实际是创建了一个closure(A)对象放在堆空间，A的闭包被赋值给谁，就是把closure(A)对象的地址给它



#### this机制

一个朴素的需求：在对象内部的方法里使用对象内部的属性, 但作用域机制不能满足。

```
var a = '反人类'
var obj = {
	a: ‘正常人’,
	foo: function() {
		console.log(a)
	}
}
obj.foo() 
// '反人类'
```

来看下执行上下文

```
栈 = [bar.foo执行上下文，全局执行上下文]
bar.foo执行上下文 = {
	变量环境： {outer: 全局执行上下文}
	词法环境：{//空的}
}
全局执行上下文 = {
	变量环境: {
		a = 反人类
		obj = 堆空间地址 = {
      a: 正常人
      foo函数
    }
	}
	词法环境：{//空的}
}
```

bar.foo执行时: 

在bar.foo执行上下文找a  -> 没有 -> 去outer指向的全局执行上下文中找a  -> 找到了反人类

- this是跟执行上下文绑定的，所以也分成全局执行上下文中的this，函数中的this，eval中的this

- 全局执行上下文中的this一般就是window，没啥好说的

- 函数中的this

  - 在全局环境中调用一个函数，函数内部的this指向全局this
  - 使用对象来调用其内部的方法，该方法指向的是对象本身

- 可以通过bind，call，apply手动设置this的值

- this的设计缺陷

  - 普通函数中的this指向全局（严格模式是undefined)

  - 嵌套函数中，内层函数的this不会从外层函数继承

    ```
    var obj = {
    	a: ‘正常人’,
    	foo: function() {
    		function bar() {
    			console.log(this)
    		}
    		bar()
    	}
    }
    obj.foo()
    ```

- 箭头函数不会创建执行上下文，所以它的this指向外部函数的this



#### new 做了什么

```
function FakeNew() {}
const foo = new FakeNew()
```

- 创建一个空对象obj
- 将构建函数的原型赋值给空对象： obj.\_\_proto\_\_ = FakeNew.prototype
- 调用FakeNew.call(obj),  这样创建FakeNew.call执行上下文时，上下文中的this会被指向obj
- return obj



#### 问题

1. 怎么解决栈溢出

```
function runStack (n) { 
	if (n === 0) return 100;
  return runStack( n- 2);
}
runStack(50000)
```

2. 闭包是怎么回收的

   赋值给全局变量的闭包会一直存在直到页面关闭，可能会导致内存泄漏

   赋值给局部变量的闭包在局部变量所在的执行上下文弹出后，会被下一次垃圾回收清理





#### 参考

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new
